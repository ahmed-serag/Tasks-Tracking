import { Task, TaskCategory, TaskStatus } from "../types";

export const formatCurrency = (amount: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(amount);
};

export const formatDate = (dateStr: string): string => {
  if (!dateStr) return '';
  const date = new Date(dateStr);
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  }).format(date);
};

export const calculateDaysBetween = (start: string, end: string): number => {
  const s = new Date(start);
  const e = new Date(end);
  const diffTime = Math.abs(e.getTime() - s.getTime());
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // Inclusive
};

// CSV Helpers
export const tasksToCSV = (tasks: Task[]): string => {
  const headers = [
    "ID", "Task Name", "Category", "Start Date", "End Date", 
    "Status", "Initial Cost", "Actual Cost", "Dependencies", "Notes"
  ];
  
  const rows = tasks.map(t => [
    t.id,
    `"${t.name.replace(/"/g, '""')}"`,
    t.category,
    t.startDate,
    t.endDate,
    t.status,
    t.initialCost,
    t.actualCost,
    `"${t.dependencies.join(',')}"`,
    `"${t.notes.replace(/"/g, '""')}"`
  ]);

  return [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
};

export const parseCSVToTasks = (csvContent: string): Task[] => {
  const lines = csvContent.split('\n');
  const tasks: Task[] = [];
  
  // Skip header, start at 1
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    // specific regex to handle quoted strings with commas
    const regex = /(".*?"|[^",\s]+)(?=\s*,|\s*$)/g;
    // Simple split won't work for quoted fields with commas. 
    // Using a more manual parse approach for robustness without external lib
    
    // Quick naive parse for this specific format
    const matches = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g);
    // Note: This naive regex is a fallback. A proper parser state machine is better, 
    // but for this MVP scope, we will assume standard CSV generated by the app or template.
    // Let's use a simpler split if no quotes, or a character walk if complex.
    
    // Let's implement a robust character walker for CSV line parsing
    const values: string[] = [];
    let current = '';
    let inQuote = false;
    
    for(let charIndex = 0; charIndex < line.length; charIndex++) {
      const char = line[charIndex];
      if (char === '"') {
        if (inQuote && line[charIndex + 1] === '"') {
          current += '"';
          charIndex++; // skip escaped quote
        } else {
          inQuote = !inQuote;
        }
      } else if (char === ',' && !inQuote) {
        values.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    values.push(current);

    if (values.length < 5) continue; // Invalid row

    tasks.push({
      id: values[0] || crypto.randomUUID(),
      name: values[1],
      category: Object.values(TaskCategory).includes(values[2] as any) ? values[2] : TaskCategory.OTHER,
      startDate: values[3],
      endDate: values[4],
      status: Object.values(TaskStatus).includes(values[5] as any) ? values[5] as TaskStatus : TaskStatus.NOT_STARTED,
      initialCost: parseFloat(values[6]) || 0,
      actualCost: parseFloat(values[7]) || 0,
      dependencies: values[8] ? values[8].split(',').filter(d => d) : [],
      notes: values[9] || ''
    });
  }
  return tasks;
};

export const downloadCSV = (content: string, filename: string) => {
  const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
};